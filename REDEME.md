🔐 1. Authentication vs Authorization

Authentication : Verifies who the user (To confirm user identity (e.g., username/password).)
Authorization : Verifies what the user can access (To enforce access rules based on roles)

✅ What is SecurityFilterChain?
SecurityFilterChain is a core interface in Spring Security that defines the sequence of filters applied to every HTTP request in your application.
this used before WebSecurityConfigurerAdapter, which is now deprecated.

🔑 Purpose
It tells Spring how to secure incoming HTTP requests.
You configure:
which endpoints are public
which require authentication
which require specific roles
how to handle login/logout
how to add JWT or custom filters

CSRF =  Disable CSRF protection – Since you're building a REST API (stateless, no sessions), CSRF is not needed.

.httpBasic(Customizer.withDefaults())
🔐 Enable basic login format for now (for testing) – e.g., use Postman to pass username/password.
This means: if someone sends a username and password in the HTTP header (Authorization: Basic ...), Spring will use it to authenticate.

.anyRequest().authenticated()
Every HTTP request must be authenticated.
It means: no matter what the URL is (/user, /admin, /home, etc.), the user must be logged in (have a valid JWT or Basic Auth).

.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
"Don't create or use any HTTP session."
In stateless mode, the server does not store any session.
Every request must bring its own token (JWT).
Useful for APIs where the client (like Postman or React frontend) always sends the JWT token.

.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
"Add our custom JWT filter (jwtAuthFilter) to run before the default username-password filter."
Before Spring checks username/password,
It will first check if a valid JWT token is present in the request (like in the Authorization header).
If the token is valid → authenticate the user.
If not → continue to default filters.

✅ 1. What is AuthenticationProvider?
It’s an interface in Spring Security used to process login authentication.
🔍 Purpose:
When a user tries to log in (e.g. sends username and password), Spring needs some way to check if those credentials are correct.
That job is done by an AuthenticationProvider.
It takes the login request,
Checks the username and password,
Returns an authenticated user if valid,
Otherwise, throws an exception (like BadCredentialsException).

✅ 2. What is DaoAuthenticationProvider?
It is a ready-made implementation of AuthenticationProvider that uses your database to validate username & password.
Instead of writing everything manually, you can use DaoAuthenticationProvider to:
Load user data from the database (via UserDetailsService)
Compare the password (using a PasswordEncoder)

AuthenticationProvider ----> Interface to handle login logic ---->	To create custom authentication logic
DaoAuthenticationProvider --->	Built-in class that uses DB to validate login --->	To authenticate users using database username/password

✅ What is AuthenticationManager?
🧠 AuthenticationManager is the main engine in Spring Security that performs authentication.
🔍 Purpose: It takes an authentication request (usually username + password),
Then it asks the configured AuthenticationProvider (like DaoAuthenticationProvider) to verify the credentials,
If successful, it returns a fully authenticated object.

✅ AuthenticationConfiguration
This line tells Spring:
"Hey, give me the AuthenticationManager you auto-configured behind the scenes using my UserDetailsService and DaoAuthenticationProvider."

Authentication authentication = authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword()));
➡️ This is the core authentication line:
Spring checks:
Is the user present in DB?
Is the password correct?
If yes → returns a valid Authentication object

UsernamePasswordAuthenticationToken (Wraps the login username and password)
A class that holds login credentials: username + password.
It's used to send the credentials to the AuthenticationManager.

UserDetails userDetails = userDetailsService.loadUserByUsername(request.getUsername());
➡️ This retrieves the full UserDetails object (username, password, roles) from the database.
This is required to generate the JWT with correct roles and info.

✅ SecretKey
A secret key is a string used to digitally sign the JWT token so that the server can verify the token’s authenticity later.
The secret key is used to sign the JWT token. 
It ensures that the token was generated by our server and hasn’t been modified by any third party. 
It’s also required for verifying the token when it is sent back with API requests.

✅ What is UserDetails?
UserDetails is an interface provided by Spring Security that holds the information of a logged-in user.
Spring Security needs to know:
Username
Password
Roles/Authorities
Account status (expired, locked, etc.)
➡️ So, instead of using your raw User entity, Spring uses UserDetails to safely and flexibly represent the user.

✅ What is UserDetailsService? 
It is a Spring Security interface that loads user (loadUserByUsername) data from the database by username.
🔍 Purpose:
Spring Security calls this service during login to:
Fetch user from the database
Convert that user into a **UserDetails object**

✅ 1. What is JwtFilter (also called JwtAuthenticationFilter)?
🔐 Simple Definition:
A custom security filter that:
Intercepts every incoming request
Extracts the JWT token from the header
Validates it
If valid → sets the authentication in the Spring Security Context
🔍 Purpose: It checks if the request has a valid JWT token.
If yes → it tells Spring Security: “This user is authenticated.”
Without this, your system won’t recognize the token in the request.

✅ 2. What is OncePerRequestFilter?
🔁 Simple Definition:
It’s a Spring Security base class used to make custom filters that run once per HTTP request.
🔍 Why use it?
You don’t want your JWT filter to run multiple times for the same request.
So, Spring gives this OncePerRequestFilter to make sure your doFilterInternal() runs only once per request.

✅ 3. What is doFilterInternal(...)?
🛠️ Simple Explanation:
It’s a method you override inside your JwtAuthFilter.
🔍 Purpose:
This is the main method where your JWT logic goes:
Get the JWT token from the request
Validate the token
Get user info from the token
Set authentication in SecurityContext

SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
"Hey, this request is now authenticated. Here is the authenticated user info (username, roles, etc.)."
In JWT authentication, we don’t use sessions, so Spring Security doesn't know the user is logged in until we manually set it.
So, after validating the JWT token and confirming the user is valid:
You create a UsernamePasswordAuthenticationToken object
Then you set it in the security context using:


🧠 Spring Security + JWT Full Flow Chart (Authentication + Token Validation)
✅ Step 1: User Sends Login Request
pgsql
Copy
Edit
Client (e.g. Postman or Frontend)
|
| POST /login  (with username + password)
|
v
✅ Step 2: You Call AuthenticationManager
pgsql
Copy
Edit
LoginController
|
| JwtAuthRequest -> (username, password)
|
| authenticationManager.authenticate(
|     new UsernamePasswordAuthenticationToken(username, password)
| )
v
✅ Step 3: AuthenticationManager Calls UserDetailsService
php
Copy
Edit
AuthenticationManager (Spring class)
|
v
DaoAuthenticationProvider
|
| -> calls your CustomUserDetailsService
v
CustomUserDetailsService implements UserDetailsService
|
| -> loadUserByUsername(username)
v
Your User Entity (from DB)
|
v
CustomUserDetails implements UserDetails
✅ Step 4: Password Checked
pgsql
Copy
Edit
DaoAuthenticationProvider
|
| -> PasswordEncoder matches password
v
If valid -> returns Authentication object ✅
If invalid -> throws BadCredentialsException ❌
✅ Step 5: JWT Token Generated
pgsql
Copy
Edit
LoginController
|
v
jwtService.generateToken(userDetails)
|
| -> Uses SECRET_KEY
| -> Creates JWT (with username, roles, expiry)
v
Returns JWT to client
✅ Step 6: Client Sends API Request with JWT
pgsql
Copy
Edit
Client
|
| GET /user/profile
| Header: Authorization: Bearer <token>
v
✅ Step 7: JwtAuthFilter Intercepts Request
sql
Copy
Edit
JwtAuthFilter extends OncePerRequestFilter
|
| -> doFilterInternal(request, response, filterChain)
|
| -> Extract token from Authorization header
| -> Validate token using jwtService
| -> Extract username from token
| -> Load UserDetails from DB
| -> If valid:
|      create UsernamePasswordAuthenticationToken
|      set it into SecurityContext:
|        SecurityContextHolder.getContext().setAuthentication(token)
v
Proceed to Controller (User is authenticated ✅)

🧩 Class & Interface Map (Who Does What)

Role ---------------------->	Class / Interface ---------->	Purpose
Holds user info ---------------->	UserDetails---------->	Contains username, password, roles
Converts DB user to UserDetails-->	CustomUserDetails---------->	Implements UserDetails
Loads user from DB-------------->	UserDetailsService---------->	Interface
Your implementation------------>	CustomUserDetailsService ---------->	Implements UserDetailsService
Core authentication engine-------->	AuthenticationManager---------->	Calls authenticate()
Used for DB login-------------->	DaoAuthenticationProvider ---------->	Validates username/password
Used in login-------------->	UsernamePasswordAuthenticationToken	----------> Carries username + password
Holds security info---------->	SecurityContextHolder ---------->	Stores authenticated user
Filter--------------------->	JwtAuthFilter ---------->	Validates token per request
Base filter class---------->	OncePerRequestFilter---------->	Runs only once per request
Main JWT logic------------->	JwtService ---------->	Generates & validates token

🎯 Bonus: Key Methods Summary
Method	Purpose
authenticate() ---------->	Authenticates the user using username + password
loadUserByUsername()---------->	Loads user details from DB
generateToken()---------->	Creates JWT token
extractUsername()---------->	Extracts username from token
isTokenValid()---------->	Checks if JWT is valid
doFilterInternal()---------->	JWT filter logic happens here
setAuthentication()---------->	Sets the authenticated user into security context